{"version":3,"sources":["script.precomp.js"],"names":[],"mappings":";;;;;;;;AACA;;;AAGA,IAAM,YAAY;AACd;;;;;;AAMA,cAAU,kBAAC,SAAD,EAAY,QAAZ,EAAyB;AAC/B,YAAI,QAAJ,EAAc;AACV,oBAAQ,SAAS,WAAjB;AACI;AACA;AACA,qBAAK,KAAL;AACI,6BAAS,GAAT,CAAa;AAAA,+BAAY,QAAQ,SAAR,CAAkB,GAAlB,CAAsB,SAAtB,CAAZ;AAAA,qBAAb;AACA;AACJ;AACA;AACA;AACA,qBAAK,MAAL;AACI;AACA,wBAAM,0CAAiB,SAAS,sBAAT,CAAgC,QAAhC,CAAjB,EAAN;AACA;AACA,2BAAO,WAAW,MAAlB,EAA0B;AACtB;AACA,4BAAI,iBAAiB,WAAW,GAAX,EAArB;AACA;AACA,uCAAe,SAAf,CAAyB,GAAzB,CAA6B,SAA7B;AACH;AACD;AACJ;AACI,0BAAM,IAAI,KAAJ,2DAAN;AArBR;AAuBH,SAxBD,MAwBQ;AACJ,kBAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;AACH;AACJ,KAnCa,EAmCX;AACH;;;;;;;;;;AAUA,iBAAa,qBAAE,SAAF,EAAa,QAAb,EAA2B;AACpC,YAAI,QAAJ,EAAc;AACV,oBAAQ,SAAS,WAAjB;AACI;AACA;AACA,qBAAK,KAAL;AACI;AACA,6BAAS,GAAT,CAAa;AAAA,+BAAY,QAAQ,SAAR,CAAkB,MAAlB,CAAyB,SAAzB,CAAZ;AAAA,qBAAb;AACA;AACJ;AACA;AACA;AACA,qBAAK,MAAL;AACI;AACA,4BAAQ,GAAR,CAAY,QAAZ;AACA;AACA,wBAAM,0CAAiB,SAAS,sBAAT,CAAgC,QAAhC,CAAjB,EAAN;AACA;AACA,2BAAO,WAAW,MAAlB,EAA0B;AACtB;AACA,4BAAI,iBAAiB,WAAW,GAAX,EAArB;AACA;AACA,uCAAe,SAAf,CAAyB,MAAzB,CAAgC,SAAhC;AACH;AACD;AACJ;AACI,0BAAM,IAAI,KAAJ,8DAAN;AAxBR;AA0BH,SA3BD,MA2BO,IAAI,SAAJ,EAAe;AAClB,gBAAM,yCAAe,SAAS,sBAAT,CAAgC,SAAhC,CAAf,EAAN;AACA,sBAAS,GAAT,CAAa;AAAA,uBAAY,QAAQ,SAAR,CAAkB,MAAlB,CAAyB,SAAzB,CAAZ;AAAA,aAAb;AACH,SAHM,MAGA;AACH,kBAAM,IAAI,KAAJ,CAAU,+CAAV,CAAN;AACH;AACJ,KAhFa,EAgFX;AACH,gBAAY,oBAAE,GAAF,EAAO,QAAP,EAAqB;AAC7B,YAAI,SAAS,SAAS,aAAT,CAAuB,QAAvB,CAAb;AACA,YAAI,SAAS,KAAb;AACA,eAAO,YAAP,CAAoB,KAApB,EAA2B,GAA3B;AACA,YAAG,QAAH,EAAY;AACR,mBAAO,kBAAP,GAA4B,OAAO,MAAP,GAAgB,YAAM;AAC9C,oBAAG,CAAC,MAAJ,EAAY;AACR;AACH;AACD,yBAAS,IAAT;AACH,aALD;AAMH;AACD,iBAAS,oBAAT,CAA8B,MAA9B,EAAsC,CAAtC,EAAyC,WAAzC,CAAqD,MAArD;AACH,KA9Fa,CA8FZ;AACJ;;AA/FgB,CAAlB,CAiGA,IAAM,SAAS;AACX;AACA,SAAK,SAFM;AAGX;AACA,eAAW;AAJA,CAAf;;AAOA;;;;;;;;;;;;;;;AAeA,IAAM,UAAU,SAAV,OAAU,CAAC,OAAD,EAAa;;AAEzB,QAAI,WAAW,CACX,aADW,CAAf;;AAIA,QAAI,SAAS,EAAb;;AAEA;;;;;;;AAOA,QAAM,iBAAiB,SAAjB,cAAiB,CAAE,eAAF,EAAmB,MAAnB,EAA2B,UAA3B,EAA2C;;AAE9D,YAAI,OAAO,WAAW,KAAtB;;AAEA,eAAM;AACF,0BAAc,IADZ;AAEF,eAFE,iBAEG;AACD,oBAAI,SAAS,eAAT,IAA4B,KAAK,cAAL,CAAoB,MAApB,CAAhC,EAA4D;AACxD,2BAAO,IAAP;AACH;AACD,oBAAI,YAAY,KAAK,IAAL,CAAU,IAAV,CAAhB;AACA,uBAAO,cAAP,CAAsB,IAAtB,EAA4B,MAA5B,EAAoC;AAChC,2BAAO,SADyB;AAEhC,kCAAc,IAFkB;AAGhC,8BAAU;AAHsB,iBAApC;AAKA,uBAAO,SAAP;AACH;AAbC,SAAN;AAeH,KAnBD;AAoBA;;AAEA,QAAG,YAAY,SAAf,EAAyB;AACrB,cAAM,IAAI,KAAJ,CAAU,oCAAV,CAAN;AACH;;AAED;AACA,QAAI,kBAAkB,OAAO,cAAP,CAAsB,OAAtB,CAAtB;AACA;AACA,aAAS,OAAO,mBAAP,CAA2B,eAA3B,CAAT;;AAEA,WAAO,OAAP,CAAgB,UAAC,MAAD,EAAY;AACxB,YAAI,aAAa,OAAO,wBAAP,CAAgC,eAAhC,EAAiD,MAAjD,CAAjB;AACA;AACA,YAAG,eAAe,SAAlB,EAA6B;AACzB,oBAAQ,IAAR,sBAAgC,MAAhC;AACA;AACA;AACH;AACD;AACA,YAAI,SAAS,OAAT,CAAiB,MAAjB,MAA6B,CAAC,CAA9B,IAAmC,OAAO,WAAW,KAAlB,KAA4B,UAAnE,EAA8E;AAC1E;AACH;AACD,eAAO,cAAP,CAAsB,eAAtB,EAAuC,MAAvC,EAA+C,eAAe,eAAf,EAAgC,MAAhC,EAAwC,UAAxC,CAA/C;AACH,KAbD;AAcH,CA5DD;AA6DA;AACA,SAAS,gBAAT,CAA0B,kBAA1B,EAA8C,YAAM;AAChD;;;;;;;;;;AADgD,QAW1C,GAX0C;AAY5C,qBAAY,SAAZ,EAAsB;AAAA;;AAClB,iBAAK,SAAL,GAAiB,SAAjB;AACA,iBAAK,IAAL,CAAU,IAAV,CAAe,IAAf;AACA,iBAAK,QAAL,CAAc,IAAd,CAAmB,IAAnB;AACH;;AAhB2C;AAAA;AAAA,mCAkBtC;AACF,oBAAI,MAAM,IAAI,SAAS,GAAb,CAAiB;AACvB,+BAAW,KAAK,SADO;AAEvB,2BAAO,oCAFgB;AAGvB,6BAAS,EAHc;AAIvB,6BAAS,EAJc;AAKvB,4BAAQ,CAAC,YAAD,EAAe,CAAC,WAAhB,CALe;AAMvB,iCAAa;AANU,iBAAjB,CAAV;AAQA,oBAAI,SAAS,IAAI,SAAS,MAAb,EAAb;AACA,uBAAO,SAAP,CAAiB,CAAC,YAAD,EAAe,CAAC,WAAhB,CAAjB,EAA+C,KAA/C,CAAqD,GAArD;AACH;AA7B2C;AAAA;AAAA,uCA8BjC;AACN,uBAAO,IAAI,OAAJ,CAAa,UAAC,OAAD,EAAU,MAAV,EAAqB;AACrC,wBAAI,OAAO,IAAI,cAAJ,EAAX;AACA,wBAAI,WAAW,EAAf;AACA,yBAAK,IAAL,CAAU,KAAV,EAAiB,MAAjB,EAAyB,IAAzB;AACA,yBAAK,gBAAL,CAAsB,cAAtB,EAAsC,kBAAtC;AACA,yBAAK,kBAAL,GAA0B,YAAM;AAC5B,4BAAG,KAAK,UAAL,KAAoB,CAApB,IAAyB,KAAK,MAAL,KAAgB,GAA5C,EAAgD;AAC5C,gCAAI,YAAW,KAAK,KAAL,CAAW,KAAK,QAAhB,CAAf;AACA,oCAAQ,UAAS,KAAjB;AACH,yBAAC,IAAI,KAAK,MAAL,KAAgB,GAApB,EAAwB;AACtB,mCAAO,eAAP;AACH;AACJ,qBAPD;AAQA,yBAAK,IAAL;AACH,iBAdM,CAAP,CADM,CAeH;AACN;AA9C0C;;AAAA;AAAA,SA+C9C;;AAEF,QAAM,MAAM,IAAI,GAAJ,CAAQ,KAAR,CAAZ;AACA;AACA;AACA;AACA,cAAU,UAAV,CAAqB,0DAArB,EAAiF,YAAM;AACnF,YAAI,QAAJ,GACK,IADL,CACW;AAAA,mBAAW,OAAO,QAAP,CAAgB,WAAhB,GAA8B,KAAzC;AAAA,SADX,EAEK,IAFL,CAEW;AAAA,mBAAO,IAAI,IAAJ,EAAP;AAAA,SAFX;AAGH,KAJD;AAKA;;;;;;;;;;;;;;;;;;;;;;;;AA1DgD,QAiF1C,IAjF0C;AAkF5C,sBAAa,SAAb,EAAwB;AAAA;;AACpB,iBAAK,QAAL,GAAgB,UAAU,QAA1B;AACA,iBAAK,GAAL,GAAW,UAAU,GAArB;AACA,iBAAK,QAAL,GAAgB,UAAU,QAA1B;AACA,iBAAK,oBAAL,GAA4B,UAAU,oBAAtC;AACA,iBAAK,aAAL,GAAqB,UAAU,aAA/B;AACA,iBAAK,MAAL,GAAc,KAAd;AACA;AACD,oBAAQ,IAAR;AACF;;AA3F2C;AAAA;AAAA,mCA4FtC;AAAA;;AACF;AACA,qBAAK,QAAL,CAAc,GAAd,CAAmB,gBAAQ;AACvB,yBAAK,gBAAL,CAAuB,OAAvB,EAAgC,MAAK,eAArC;AACH,iBAFD;AAGA;AACA,qBAAK,QAAL,CAAc,gBAAd,CAA+B,QAA/B,EAAyC,KAAK,UAA9C;AACH;AAnG2C;AAAA;AAAA,gDAqGxB;AAChB,uBAAO,CAAC,KAAK,QAAN,EAAgB,KAAK,GAArB,EAA0B,KAAK,oBAA/B,EAAqD,KAAK,aAA1D,CAAP;AACH;AAvG2C;AAAA;AAAA,8CAyG1B;AACd,qBAAK,QAAL,CAAc,OAAd,GAAwB,KAAxB;AACA,qBAAK,UAAL;AACH;AA5G2C;AAAA;AAAA,yCA8G/B;AACT;AACA,oBAAI,iBAAiB,KAAK,iBAAL,EAArB;AACA,qBAAK;AACD;AADJ,kBAEM,UAAU,WAAV,CAAsB,QAAtB,EAAgC,cAAhC;AACF;AAHJ,kBAIM,UAAU,QAAV,CAAmB,QAAnB,EAA6B,cAA7B,CAJN;AAKA;AACA,qBAAK,MAAL,GAAc,CAAC,KAAK,MAApB;AACH;AAxH2C;;AAAA;AAAA,SAyH9C;AACF;;;;;AAGA,QAAM,eAAe;AACjB,kBAAU,SAAS,cAAT,CAAwB,MAAxB,CADO;AAEjB,aAAK,SAAS,sBAAT,CAAgC,KAAhC,EAAuC,CAAvC,CAFY;AAGjB,+CAAc,SAAS,gBAAT,CAA0B,YAA1B,CAAd,EAHiB;AAIjB,8BAAsB,SAAS,sBAAT,CAAgC,QAAhC,EAA0C,CAA1C,CAJL;AAKjB,uBAAe,SAAS,aAAT,CAAuB,iBAAvB;AALE,KAArB;AAOA,QAAM,OAAO,IAAI,IAAJ,CAAS,YAAT,EAAuB,IAAvB,EAAb;;AAEA;;;AAGA;;AAzIgD,QA0I1C,IA1I0C;AA2I5C,sBAAY,IAAZ,EAAkB,QAAlB,EAA4B,cAA5B,EAA2C;AAAA;;AACvC,iBAAK,IAAL,GAAY,IAAZ;AACA,iBAAK,QAAL,GAAgB,QAAhB;AACA,iBAAK,cAAL,GAAsB,cAAtB;AACA,iBAAK,UAAL,GAAkB,KAAlB;AACA,iBAAK,MAAL,GAAc;AACE,uBAAO,6BAAI,KAAK,QAAT,GAAmB,MAAnB,CAA2B;AAAA,2BAAe,QAAQ,IAAR,KAAiB,OAAhC;AAAA,iBAA3B,CADT;AAEE,sBAAM,6BAAI,KAAK,QAAT,GAAmB,MAAnB,CAA4B;AAAA,2BAAgB,QAAQ,IAAR,KAAiB,MAAjB,IACD,QAAQ,IAAR,KAAiB,UADhB,IAED,QAAQ,IAAR,KAAiB,OAFhC;AAAA,iBAA5B,CAFR;AAKE,0BAAU,6BAAI,KAAK,QAAT,GAAmB,MAAnB,CAA2B;AAAA,2BAAY,QAAQ,IAAR,KAAiB,UAA7B;AAAA,iBAA3B;AALZ,aAAd;AAOA,iBAAK,IAAL,GAAY,KAAK,IAAL,CAAU,IAAV,CAAe,IAAf,CAAZ;AACA,iBAAK,MAAL,GAAc,KAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB,CAAd;AACA,iBAAK,MAAL,GAAc,KAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB,CAAd;AACA,iBAAK,aAAL,GAAqB,KAAK,aAAL,CAAmB,IAAnB,CAAwB,IAAxB,CAArB;AACA,iBAAK,WAAL,GAAmB,KAAK,WAAL,CAAiB,IAAjB,CAAsB,IAAtB,CAAnB;AACA,iBAAK,cAAL,GAAsB,KAAK,cAAL,CAAoB,IAApB,CAAyB,IAAzB,CAAtB;AACH;;AA7J2C;AAAA;AAAA,mCA+JrC;AACH,qBAAK,IAAL,CAAU,gBAAV,CAA2B,QAA3B,EAAqC,KAAK,aAA1C;AACH;AAjK2C;AAAA;AAAA,0CAmK9B,CAnK8B,EAmK3B;AACb,kBAAE,cAAF;AACA,oBAAI,WAAW,KAAK,IAAL,CAAU,QAAzB;AACA,oBAAI,aAAa,KAAK,WAAL,CAAiB,QAAjB,CAAjB;AACA,wBAAQ,GAAR,CAAY,UAAZ;AACA;AACA,6BACU,KAAK,MAAL,CAAY,QAAZ,CADV,GAEU,KAAK,MAAL,CAAY,KAAK,cAAL,EAAZ,CAFV;AAGA,uBAAO,KAAP;AACH;AA7K2C;AAAA;AAAA,0CAqN7B;AACX;AACA;AACC,oBAAI,KAAK,UAAL,KAAoB,IAAxB,EAA8B,OAAO,IAAP;AAC/B;AACA,oBAAI,cAAoB,KAAK,MAAL,CAAY,KAApC;AAAA,oBACI,aAAoB,KAAK,MAAL,CAAY,IADpC;AAAA,oBAEI,iBAAoB,KAAK,MAAL,CAAY,QAFpC;AAGA;AACA;AACA;AACA,oBAAI,aAAoB,cAAa,KAAK,gBAAL,CAAsB,WAAtB,CAAb,GAAkD,IAA1E;AAAA,oBACI,YAAoB,aAAY,KAAK,eAAL,CAAqB,UAArB,CAAZ,GAA+C,IADvE;AAAA,oBAEI,gBAAoB,iBAAgB,KAAK,mBAAL,CAAyB,cAAzB,CAAhB,GAA2D,IAFnF;AAGA;AACA,uBAAO,cAAc,SAAd,IAA2B,aAAlC;AACH;AArO2C;AAAA;AAAA,2CAuO5B,QAvO4B,EAuOlB;AAAA;;AACrB;AACA;;;AAGA;AACA;AACA;AACA;AACA,oBAAI,aAAa,KAAK,MAAL,CAAY,IAAZ,CAAiB,GAAjB,CAAsB;AAAA,2BAAU;AAC7C,8BAAM,MAAM,IADiC;AAE7C,+BAAO,KAAK,eAAL,CAAqB,CAAC,KAAD,CAArB,CAFsC;AAG7C,8BAAM;AAHuC,qBAAV;AAAA,iBAAtB,CAAjB;AAKA;AACA;AACA,6BAAa,WAAW,MAAX,CAAmB;AAAA,2BAAQ,CAAC,KAAK,KAAd;AAAA,iBAAnB,CAAb;;AAEA;AACA;AACA;AACA;AACA,oBAAI,2CAAkB,IAAI,GAAJ,CAAQ,KAAK,MAAL,CAAY,KAAZ,CAAkB,GAAlB,CAAuB,iBAAS;AAC1D,2BAAO,MAAM,IAAb;AACH,iBAF6B,CAAR,CAAlB,EAAJ;AAGA;;;AAGA;AACA,oBAAI,cAAc,YAAY,GAAZ,CAAiB;AAAA,2BAAQ,OAAK,IAAL,CAAU,IAAV,CAAR;AAAA,iBAAjB,CAAlB;AACA;AACA;AACA,2DAAkB,WAAlB;AACA;AACA;AACA,8BAAc,YAAY,MAAZ,CAAoB;AAAA,2BAAS,CAAC,MAAM,KAAhB;AAAA,iBAApB,CAAd;AACA;AACA,8BAAc,YAAY,GAAZ,CAAiB;AAAA,2BAAU;AACrC;AACA;AACA;AACA;AACD,8BAAM,MAAM,CAAN,EAAS,IALuB;AAMrC;AACA;AACA;AACA;AACD,+BAAO,CAAC,CAAC,MAAM,KAVuB;AAWtC,8BAAM;AAXgC,qBAAV;AAAA,iBAAjB,CAAd;AAaA;;;AAGA;AACA;AACA;AACA,oBAAI,iBAAiB,KAAK,MAAL,CAAY,QAAZ,CAAqB,MAArB,CAA6B;AAAA,2BAAc,CAAC,SAAS,OAAV,IAAqB,SAAS,QAA5C;AAAA,iBAA7B,CAArB;AACA,iCAAiB,eAAe,GAAf,CAAoB;AAAA,2BAAU;AAC3C,8BAAM,MAAM,IAD+B;AAE3C,+BAAO,MAAM,OAF8B;AAG3C,8BAAM;AAHqC,qBAAV;AAAA,iBAApB,CAAjB;AAKA;;;AAGA,oBAAI,cAAc,WAAW,MAAX,CAAkB,WAAlB,EAA+B,cAA/B,CAAlB;;AAEA,wBAAQ,KAAR,CAAc,WAAd;AACD,uBAAO,WAAP;AACH;AA5S2C;AAAA;AAAA,mCA8SrC,QA9SqC,EA8S3B;AACb,wBAAQ,GAAR,CAAY,iBAAZ;AACA,qBAAK,QAAL,IAAiB,KAAK,QAAL,CAAc,QAAd,CAAjB;AACH;AAjT2C;AAAA;AAAA,mCAmTrC,MAnTqC,EAmT9B;AACV,wBAAQ,KAAR,CAAc,iBAAd;AACA,qBAAK,cAAL,GAAsB,KAAK,cAAL,CAAoB,MAApB,CAAtB,GAAoD,QAAQ,KAAR,CAAc,MAAd,CAApD;AACH;AAtT2C;AAAA;AAAA,6CA+KpB,WA/KoB,EA+KP;AACjC;AACA;AACA;AACA;AACA,oBAAI,sBAAsB,IAAI,GAAJ,CAAQ,YAAY,GAAZ,CAAiB;AAAA,2BAAS,MAAM,IAAf;AAAA,iBAAjB,CAAR,EAAgD,IAA1E;AACA;AACA;AACA,oBAAI,wBAAwB,YAAY,MAAZ,CAAoB;AAAA,2BAAS,MAAM,OAAf;AAAA,iBAApB,EAA6C,MAAzE;AACA;AACA,uBAAO,wBAAwB,qBAA/B;AACH;AA1L2C;AAAA;AAAA,4CA2LrB,UA3LqB,EA2LT;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAO,CAAC,WAAW,GAAX,CAAgB;AAAA,2BAAS,MAAM,QAAN,GAAgB,CAAC,CAAC,MAAM,KAAxB,GAAgC,IAAzC;AAAA,iBAAhB,EAAgE,QAAhE,CAAyE,KAAzE,CAAR;AACH;AApM2C;AAAA;AAAA,gDAqMjB,cArMiB,EAqMD;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAO,CAAC,eAAe,GAAf,CAAoB;AAAA,2BAAS,MAAM,QAAN,GAAgB,MAAM,OAAtB,GAAgC,IAAzC;AAAA,iBAApB,EAAoE,QAApE,CAA6E,KAA7E,CAAR;AACH;AA/M2C;AAAA;AAAA,4CAiNrB,WAjNqB,EAiNT,CAElC;AAnN2C;;AAAA;AAAA;;AAyThD,QAAM,sBAAsB,SAAtB,mBAAsB,CAAC,QAAD,EAAc;;AAEtC,YAAI,OAAO,SAAS,IAAT,CAAc,KAAzB;AAAA,YACI,OAAO,SAAS,IAAT,CAAc,KAAd,IAAqB,EADhC;AAAA,YAEI,OAAO,SAAS,IAAT,CAAc,KAAd,IAAqB,QAFhC;;AAIA;AACA,YAAI,WAAW,SAAS,aAAT,CAAuB,iBAAvB,CAAf;AACA,YAAI,mBAAmB,SAAS,aAAT,CAAuB,yBAAvB,CAAvB;;AAEA,iBAAS,WAAT,GAAuB,KAAK,WAAL,EAAvB;AACA,yBAAiB,WAAjB,aAAuC,IAAvC,SAA+C,IAA/C;;AAEA;AACA,YAAI,0CAAiB,SAAS,gBAAT,CAA0B,4CAA1B,CAAjB,EAAJ;AACA,mBAAW,OAAX,CAAoB;AAAA,mBAAc,UAAU,SAAV,CAAoB,GAApB,CAAwB,WAAxB,CAAd;AAAA,SAApB;AACH,KAhBD;;AAkBA,QAAM,sBAAsB,SAAtB,mBAAsB,CAAC,MAAD,EAAY;AACpC;AACA,YAAM,iBAAiB,SAAS,iBAAT,CAA2B,QAA3B,EAAqC,CAArC,CAAvB;AACA;AACA,SAAC,eAAe,SAAf,CAAyB,QAAzB,CAAkC,QAAlC,CAAD,IAAgD,eAAe,SAAf,CAAyB,GAAzB,CAA6B,QAA7B,CAAhD;AACA,YAAM,OAAO,eAAe,aAAf,CAA6B,IAA7B,CAAb;AACA,aAAK,SAAL,GAAiB,OAAO,GAAP,CAAY;AAAA,4BAAgB,MAAM,IAAtB,UAA+B,MAAM,IAArC;AAAA,SAAZ,EAA4E,IAA5E,CAAiF,GAAjF,CAAjB;AACH,KAPD;;AASA,QAAM,2BAA2B,SAA3B,wBAA2B;AAAA,eAAK,EAAE,cAAF,IAAoB,EAAE,cAAF,EAAzB;AAAA,KAAjC;;AAEA,QAAM,kBAAkB,SAAlB,eAAkB,CAAC,QAAD,EAAc;AAClC,gBAAQ,GAAR,CAAY,YAAZ;AACA,YAAI,OAAO,SAAS,KAAT,CAAe,CAAf,CAAX;AACA,YAAI,eAAe,SAAS,aAAT,CAAuB,4BAAvB,CAAnB;AACA,YAAI,SAAS,SAAS,iBAAT,CAA2B,gBAA3B,EAA6C,CAA7C,CAAb;AACA,eAAO,SAAP,CAAiB,GAAjB,CAAqB,gBAArB;AACA,eAAO,SAAP,CAAiB,GAAjB,CAAqB,UAArB;AACA;AACA,qCAAI,KAAK,QAAT,GAAmB,OAAnB,CAA4B;AAAA,mBAAQ,GAAG,YAAH,CAAgB,UAAhB,EAA4B,IAA5B,CAAR;AAAA,SAA5B;AACH,KATD;;AAWA,QAAM,YAAY,IAAI,IAAJ,CAAS,SAAS,KAAT,CAAe,CAAf,CAAT,EAA4B,mBAA5B,EAAiD,mBAAjD,EAAsE,IAAtE,EAAlB;AACA,QAAM,cAAc,IAAI,IAAJ,CAAS,SAAS,KAAT,CAAe,CAAf,CAAT,EAA2B,eAA3B,EAA4C,IAA5C,EAApB;AAEH,CApWD,E,CAoWI","file":"script.js","sourcesContent":["\n/*\nUTILITY FUNCTIONS\n */\nconst Utilities = {\n    /**\n     *  addClass method\n     * @param className = className to add\n     * @param elements  = elements to add className to\n     *\n     */\n    addClass: (className, elements) => {\n        if (elements) {\n            switch (elements.constructor) {\n                //  If elements type is Array, sweet go through\n                // add the className from the element.classList\n                case Array:\n                    elements.map(element => (element.classList.add(className)));\n                    break;\n                //  If elements type is String, sweet go through\n                //  define an array of that String and add the\n                //  className from each element.classList\n                case String:\n                    // make the array\n                    const collection = [...document.getElementsByClassName(elements)];\n                    // while the array has a length\n                    while (collection.length) {\n                        // take the last item off the array\n                        let currentElement = collection.pop();\n                        // manipulate it's class\n                        currentElement.classList.add(className);\n                    }\n                    break;\n                default:\n                    throw new Error(`Could not add classNames from elements, check arguments`);\n            }\n        }  else {\n            throw new Error('Could not add classes, check arguments');\n        }\n    }, // end of addClass() function\n    /**\n     *\n     * @param className = className to remove\n     * @param elements (option) = Array or String of element(s)\n     *                            to remove from\n     *\n     * If no elements are provided, the elements\n     * containing the class to remove will targeted.\n     *\n     */\n    removeClass: ( className, elements ) => {\n        if (elements) {\n            switch (elements.constructor) {\n                //  If elements type is Array, sweet go through\n                // remove the className from the element.classList\n                case Array:\n                    /*$FlowFixMe*/\n                    elements.map(element => (element.classList.remove(className)));\n                    break;\n                //  If elements type is String, sweet go through\n                //  define an array of that String and remove the\n                //  className from each element.classList\n                case String:\n                    // make the array\n                    console.log(elements);\n                    /*$FlowFixMe*/\n                    const collection = [...document.getElementsByClassName(elements)];\n                    // while the array has a length\n                    while (collection.length) {\n                        // take the last item off the array\n                        let currentElement = collection.pop();\n                        // manipulate it's classes\n                        currentElement.classList.remove(className);\n                    }\n                    break;\n                default:\n                    throw new Error(`Could not remove classNames from elements, check arguments`);\n            }\n        } else if (className) {\n            const elements = [...document.getElementsByClassName(className)];\n            elements.map(element => (element.classList.remove(className)));\n        } else {\n            throw new Error('Could not manipulate classes, check arguments');\n        }\n    }, // end of removeClass\n    loadScript: ( src, callback ) => {\n        let script = document.createElement('script');\n        let loaded = false;\n        script.setAttribute('src', src);\n        if(callback){\n            script.onreadystatechange = script.onload = () => {\n                if(!loaded) {\n                    callback();\n                }\n                loaded = true;\n            };\n        }\n        document.getElementsByTagName('head')[0].appendChild(script);\n    } // end loadScript\n} /*end of Utilities*/\n\nconst Styles = {\n    // cta a.k.a BEAN\n    cta: \"#b14d61\",\n    // bean darker\n    ctaDarker: \"#9e465b\"\n};\n\n/*\nClass autobind function\n\nInspired heavily by react-autobind which I <3.\n\nI wanted to see how it works under the hood and replicate\nit and change things to ES6 where I can, but mostly\nto learn something! I don't claim any of this work\n'as my own' The genius lies with the original\nauthors.\n\nCheck out react-autobind here:\nhttps://github.com/cassiozen/React-autobind/blob/master/src/autoBind.js\n\n// */\nconst bindAll = (context) => {\n\n    let dontBind = [\n        'constructor'\n    ];\n\n    let toBind = [];\n\n    /**\n     * From autobind-decorator (https://github.com/andreypopp/autobind-decorator/tree/master)\n     * Rewritten in an arrow function\n     * Return a descriptor removing the value and returning a getter\n     * The getter will return a .bind version of the function\n     * and memoize the result against a symbol on the instance\n     */\n    const getBoundMethod = ( objectPrototype, method, descriptor ) => {\n\n        let func = descriptor.value;\n\n        return{\n            configurable: true,\n            get(){\n                if( this === objectPrototype || this.hasOwnProperty(method)){\n                    return func;\n                }\n                let boundFunc = func.bind(this);\n                Object.defineProperty(this, method, {\n                    value: boundFunc,\n                    configurable: true,\n                    writable: true\n                });\n                return boundFunc;\n            }\n        }\n    };\n    // Onto binding them all\n\n    if(context === undefined){\n        throw new Error('bindAll Error: No context provided');\n    }\n\n    // get Object Prototype\n    let objectPrototype = Object.getPrototypeOf(context);\n    // prepare to bind all methods on the class\n    toBind = Object.getOwnPropertyNames(objectPrototype);\n\n    toBind.forEach( (method) => {\n        let descriptor = Object.getOwnPropertyDescriptor(objectPrototype, method);\n        // if the method doesn't exist, warn user\n        if(descriptor === undefined ){\n            console.warn(`bindAll Error: \"${method}\" not found in class`)\n            // then return;\n            return;\n        }\n        // if it isn't a function or is a abnormal function return\n        if( dontBind.indexOf(method) !== -1 || typeof descriptor.value !== 'function'){\n            return;\n        }\n        Object.defineProperty(objectPrototype, method, getBoundMethod(objectPrototype, method, descriptor));\n    });\n};\n// Wait for the DOM Content to finish loading\ndocument.addEventListener('DOMContentLoaded', () => {\n    /**\n     * @class Map contains the logic needed to render\n     *        a mapbox map\n     *\n     * @function setToken gets the token from the server\n     *           and returns a promise with the token\n     *\n     * @function init initiates the map, should be called\n     *           in the resolve of the above function\n     */\n    class Map {\n        constructor(container){\n            this.container = container;\n            this.init.bind(this);\n            this.setToken.bind(this);\n        }\n\n        init(){\n            let map = new mapboxgl.Map({\n                container: this.container,\n                style: 'mapbox://styles/mapbox/streets-v10',\n                minZoom: 14,\n                maxZoom: 24,\n                center: [153.02138889, -27.47797222],\n                interactive: false\n            });\n            let marker = new mapboxgl.Marker();\n            marker.setLngLat([153.02138889, -27.47797222]).addTo(map);\n        }\n         setToken(){\n             return new Promise( (resolve, reject) => {\n                 let http = new XMLHttpRequest();\n                 let response = {};\n                 http.open(\"GET\", '/map', true);\n                 http.setRequestHeader(\"Content-Type\", \"application/json\");\n                 http.onreadystatechange = () => {\n                     if(http.readyState === 4 && http.status === 200){\n                         let response = JSON.parse(http.response);\n                         resolve(response.token);\n                     } if( http.status === 403){\n                         reject('403 Forbidden');\n                     }\n                 }\n                 http.send();\n             }) //  getToken()\n         }\n    } // end Map\n\n    const map = new Map('map');\n    // to make sure mapboxgl is on the window element we'll append and load\n    // it using JS, and then grab the token to set it, followed finally by\n    // initiating the map\n    Utilities.loadScript(\"https://api.mapbox.com/mapbox-gl-js/v0.44.2/mapbox-gl.js\", () => {\n        map.setToken()\n            .then( token => ( window.mapboxgl.accessToken = token ))\n            .then( () => (map.init()));\n    });\n    /**\n     * @class Menu contains all logic and functionality for\n     * the menu.\n     * Call function Menu.init() to operate.\n     *\n     * Pass in an Object {} containing\n     * menuIcon - Icon being used for the menu (usually\n     * the label in the 'checkbox' hack.\n     *\n     * nav – the high container element that\n     * has all the menu items in it. Usually\n     * a <nav> element.\n     *\n     * navItems – Array of all the links in the\n     * navigation.\n     *\n     * navigationBackground – The element to put up\n     * when the menu is active.\n     *\n     * menuContainer – the parent container element of\n     * all the elements that pertain to navigation\n     *\n     */\n    class Menu {\n        constructor( menuItems ){\n            this.menuIcon = menuItems.menuIcon;\n            this.nav = menuItems.nav;\n            this.navItems = menuItems.navItems;\n            this.navigationBackground = menuItems.navigationBackground;\n            this.menuContainer = menuItems.menuContainer;\n            this.isOpen = false;\n            // bind those functions up to 'this'\n           bindAll(this);\n        }\n        init(){\n            // add handleSelection to each link\n            this.navItems.map( link => {\n                link.addEventListener( 'click', this.handleSelection);\n            });\n            // add toggleMenu to change event on menuIcon (i.e. checkbox)\n            this.menuIcon.addEventListener('change', this.toggleMenu);\n        }\n\n        getToggleElements() {\n            return [this.menuIcon, this.nav, this.navigationBackground, this.menuContainer];\n        }\n\n        handleSelection() {\n            this.menuIcon.checked = false;\n            this.toggleMenu();\n        };\n\n        toggleMenu() {\n            // get the toggleElements;\n            let toggleElements = this.getToggleElements();\n            this.isOpen\n                // if isOpen == true remove classes\n                ? Utilities.removeClass('active', toggleElements)\n                // else if isOpen == false add classes\n                : Utilities.addClass('active', toggleElements);\n            // toggle state\n            this.isOpen = !this.isOpen;\n        };\n    } // end of class Menu\n    /*\n   Menu elements\n    */\n    const menuElements = {\n        menuIcon: document.getElementById('menu'),\n        nav: document.getElementsByClassName('nav')[0],\n        navItems: [...document.querySelectorAll('.nav__link')],\n        navigationBackground: document.getElementsByClassName('nav-bg')[0],\n        menuContainer: document.querySelector('.menu-container')\n    };\n    const menu = new Menu(menuElements).init();\n\n    /**\n     * FORM FUNCTIONALITY\n     */\n    //\n    class Form {\n        constructor(form, callback, rejectCallback){\n            this.form = form;\n            this.callback = callback;\n            this.rejectCallback = rejectCallback;\n            this.noValidate = false;\n            this.inputs = {\n                            radio: [...form.elements].filter( element =>    (element.type === 'radio' )),\n                            text: [...form.elements].filter(  element =>     (element.type === 'text' ||\n                                                                             element.type === 'textarea' ||\n                                                                             element.type === 'email')),\n                            checkbox: [...form.elements].filter( element => (element.type === 'checkbox')),\n                        };\n            this.init = this.init.bind(this);\n            this.submit = this.submit.bind(this);\n            this.reject = this.reject.bind(this);\n            this.submitHandler = this.submitHandler.bind(this);\n            this.isFormValid = this.isFormValid.bind(this);\n            this.generateErrors = this.generateErrors.bind(this);\n        }\n\n        init() {\n            this.form.addEventListener('submit', this.submitHandler);\n        }\n\n        submitHandler(e) {\n            e.preventDefault();\n            let elements = this.form.elements;\n            let formStatus = this.isFormValid(elements);\n            console.log(formStatus);\n            // if orderStatus is all good, submit, otherwise reject and give reason\n            formStatus\n                    ? this.submit(elements)\n                    : this.reject(this.generateErrors());\n            return false;\n        }\n\n        static checkRadioInputs(radioInputs) {\n            // TODO: add required support\n            // using the Set object by mapping over the names we can pick out the\n            // unique values and immediately return the size of the Set to get our\n            // number of radio groups\n            let numberOfRadioGroups = new Set(radioInputs.map( input => input.name )).size;\n            // similarly we can grab the checked values by filter(ing) through all the\n            // radio inputs and grabbing the length of that array\n            let numberOfCheckedInputs = radioInputs.filter( input => input.checked ).length;\n            // these number should equal each other.\n            return numberOfRadioGroups === numberOfCheckedInputs;\n        }\n        static checkTextInputs(textInputs) {\n            // map over text inputs, check if the input is required\n            // if it is coerce it's value to a boolean,\n            // if there are any falsey values\n            // in the returned array, it means we have\n            // an invalid input. Flip the return value\n            // to bring the result inline with\n            // the other validation functions\n            return !textInputs.map( input => input.required? !!input.value : true ).includes(false);\n        }\n        static checkCheckboxInputs(checkboxInputs) {\n            // pretty much a copy pasta from above.. but here is how it works:\n            // map over text inputs, check if the input is required\n            // if it return it's input.checked value (i.e. true or false),\n            // if there are any falsey values\n            // in the returned array, it means we have\n            // an invalid input. Flip the return value\n            // to bring the result inline with\n            // the other validation functions\n            return !checkboxInputs.map( input => input.required? input.checked : true ).includes(false);\n        }\n\n        static checkEmailInput(emailInputs){\n\n        }\n\n         isFormValid() {\n            // if noValidate === true just return true\n            // because we don't need to validate anything\n             if (this.noValidate === true) return true;\n            // name our inputs human friendly\n            let radioInputs     =   this.inputs.radio,\n                textInputs      =   this.inputs.text,\n                checkboxInputs  =   this.inputs.checkbox;\n            // check which types we need to validate\n            // and run validation where its required\n            // otherwise give us true\n            let radioValid      =   radioInputs? Form.checkRadioInputs(radioInputs) : true,\n                textValid       =   textInputs? Form.checkTextInputs(textInputs) : true,\n                checkboxValid   =   checkboxInputs? Form.checkCheckboxInputs(checkboxInputs) : true;\n            // is the form valid? if all values are true–apparently so.\n            return radioValid && textValid && checkboxValid;\n        };\n\n         generateErrors(elements) {\n             // let errorReport = [];\n             /*\n            ******* Text Inputs\n             */\n             // checking for the false text inputs is\n             // fairly easy. We can leverage our checkTextInputs function\n             // to assist in constructing an object for each input that\n             // holds is valid status.\n             let textInputs = this.inputs.text.map( input => ({\n                 name: input.name,\n                 valid: Form.checkTextInputs([input]),\n                 type: 'text'\n             }));\n             // After returning this array\n             // filter through it and remove the items that are valid\n             textInputs = textInputs.filter( item => !item.valid );\n\n             // radio inputs are a bit more tricky, as they'll only\n             // basically we need to grab the unique names to determined\n             // the radio groups, then we need to test that each name\n             // has a value, if it does they're all answered\n             let uniqueNames = [...new Set(this.inputs.radio.map( input => {\n                 return input.name\n             }))];\n             /*\n             ******* Radio Groups\n              */\n             // now get the NodeRadioList for each radioGroup\n             let radioGroups = uniqueNames.map( name => this.form[name] );\n             // turn it into and array to inherit\n             // Array.prototype methods\n             radioGroups = [...radioGroups];\n             // filter radioGroups and get the groups\n             // with no value, i.e. no selection made.\n             radioGroups = radioGroups.filter( group => !group.value );\n             // prepare the errors object for each group\n             radioGroups = radioGroups.map( group => ({\n                 // we have to grab the name of one\n                 // of the radio inputs inside the group\n                 // just grab the first one.\n                 // Arrays start at zero. ;)\n                name: group[0].name,\n                 // the value of the group should be \"\" so\n                 // lets just turn that into a false value\n                 // if for some reason it's not \"\" we won't\n                 // be lying.\n                valid: !!group.value,\n                type: 'radio'\n             }));\n             /*\n            ******* Checkboxes\n             */\n             // lets filter all the checkboxes in the form\n             // grab those that are not checked, and are required\n             // put them into the pretty object.\n             let checkboxInputs = this.inputs.checkbox.filter( checkbox =>  (!checkbox.checked && checkbox.required));\n             checkboxInputs = checkboxInputs.map( input => ({\n                 name: input.name,\n                 valid: input.checked,\n                 type: 'checkbox'\n             }));\n             /*\n            ******* Concat the errors\n             */\n             let errorReport = textInputs.concat(radioGroups, checkboxInputs);\n\n             console.error(errorReport);\n            return errorReport;\n        }\n\n        submit(elements) {\n            console.log('submit callback');\n            this.callback && this.callback(elements);\n        }\n\n        reject(errors){\n            console.error('reject callback');\n            this.rejectCallback ? this.rejectCallback(errors) : console.error(errors);\n        }\n    }\n\n    const orderSubmitCallback = (elements) => {\n\n        let name = elements.name.value,\n            size = elements.size.value||'',\n            type = elements.type.value||'coffee';\n\n        // populate the order summary\n        let nameSpan = document.querySelector('[data-nameSpan]');\n        let orderSummarySpan = document.querySelector('[data-orderSummarySpan]');\n\n        nameSpan.textContent = name.toLowerCase();\n        orderSummarySpan.textContent = `Your ${size} ${type} will be ready for you. Until then, we chillin'`\n\n        // drop the order card and rise the summary card\n        let containers = [...document.querySelectorAll(\"[class^='section__order-form-container--']\")];\n        containers.forEach( container => (container.classList.add('submitted')) );\n    };\n\n    const orderRejectCallback = (errors) => {\n        // get the container\n        const errorContainer = document.getElementsByName('errors')[0];\n        // set the error text in the container\n        !errorContainer.classList.contains('active') && errorContainer.classList.add('active');\n        const list = errorContainer.querySelector('ul');\n        list.innerHTML = errors.map( error => `<li>${error.name}: ${error.name} is required.</li>` ).join(' ');\n    }\n\n    const preventDefaultSubmission = e => e.preventDefault && e.preventDefault();\n\n    const contactCallback = (elements) => {\n        console.log('contact cb')\n        let form = document.forms[1];\n        let confirmation = document.querySelector('[data-name=\"contact-body\"]');\n        let button = document.getElementsByName('contact_submit')[0];\n        button.classList.add('btn--submitted');\n        button.classList.add('response');\n        // form.contact_submit.textContent = `Thanks  \\u2714`;\n        [...form.elements].forEach( el => ( el.setAttribute('disabled', true)));\n    }\n\n    const orderForm = new Form(document.forms[0], orderSubmitCallback, orderRejectCallback).init();\n    const contactForm = new Form(document.forms[1],contactCallback).init();\n\n}); /*end of DOMContentLoaded*/\n"]}